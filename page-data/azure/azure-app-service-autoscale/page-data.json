{
    "componentChunkName": "component---node-modules-gatsby-theme-kb-src-templates-topic-js",
    "path": "/azure/azure-app-service-autoscale",
    "result": {"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"azure, cloud, azure-certifications/az204, autoscaling\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Azure App Service Autoscale\"), mdx(\"p\", null, \"Autoscaling is a cloud system or process that adjusts available resources based on the current demand.\"), mdx(\"p\", null, \"Autoscaling performs \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/scale-in-out\",\n    \"title\": \"scale-in-out\"\n  }, \"[[scale-in-out]]\"), \" as opposed to scaling up and down.\"), mdx(\"p\", null, \"Autoscaling can be triggered according to a schedule or by assessing whether the system is running short on resources.\"), mdx(\"p\", null, \"Autoscaling responds to changes in the environment by adding or removing web servers and balancing the load between them.\"), mdx(\"p\", null, \"Autoscaling doesn't have any effect on the CPU power, memory, or storage capacity of the web servers powering the app; \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"it only changes the number of web servers\"), \".\"), mdx(\"p\", null, \"Autoscaling makes its decisions based on rules that you define. A rule specifies the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"threshold for a metric\"), \", and triggers an autoscale event when this threshold is crossed. Autoscaling can also deallocate resources when the workload has diminished.\"), mdx(\"p\", null, \"Autoscaling should only be used on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"genuine\"), \" requests. For example, a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/DoS\",\n    \"title\": \"DoS\"\n  }, \"[[DoS]]\"), \" attack will flood the server with malicious resources. Trying to handle these requests is useless (and expensive), so it's better to detect them and discard them.\"), mdx(\"p\", null, \"Autoscaling provides \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/elasticity\",\n    \"title\": \"elasticity\"\n  }, \"[[elasticity]]\"), \" for your services, allowing you to add resources during peaks like special events or remove resources during weekends. It also improves \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/availability\",\n    \"title\": \"availability\"\n  }, \"[[availability]]\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Fault-tolerance\",\n    \"title\": \"Fault tolerance\"\n  }, \"[[Fault tolerance]]\"), \", ensuring that client requests won't be rejected because the instance has crashed.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Autoscaling isn't the best approach to handling long-term growth.\"), \" You might have a web app that starts with a few users but increases in popularity over time. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Autoscaling has an overhead associated with monitoring resources and determining whether to trigger a scaling event\"), \". In this scenario, if you can anticipate the rate of growth, manually scaling the system over time may be a more cost-effective approach.\"), mdx(\"p\", null, \"Autoscaling is also affected by the number of instances of the service. The fewer the number of instances initially, the less capacity you have to handle an increasing workload while autoscaling spins up more instances.\"), mdx(\"p\", null, \"Autoscaling is a feature tightly bound to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/azure-app-service-plan\",\n    \"title\": \"azure-app-service-plan\"\n  }, \"[[azure-app-service-plan]]\"), \". Each Service Plan has an associated scaling limit that cannot be surpassed. Not all service plans support autoscaling. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"The development pricing tiers are either limited to a single instance (the F1 and D1 tiers)\"), \", or they only provide \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"manual scaling (the B1 tier)\"), \". If you've selected one of these tiers, you must first scale up to the S1 or any of the P-level production tiers.\"), mdx(\"h2\", null, \"Autoscale conditions and rules\"), mdx(\"p\", null, \"You indicate how to autoscale by creating \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"autoscale conditions\"), \". Azure provides two options for autoscaling:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Scale based on a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"metric\"), \", such as the length of the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/disk-queue\",\n    \"title\": \"disk queue\"\n  }, \"[[disk queue]]\"), \" or the number of HTTP requests awaiting processing.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Scale to a specific instance count according to a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"schedule\"), \". For example, you can arrange to scale out at a particular time of day or on a specific date or day of the week. You also specify an end date, and the system scales back in at that time.\")), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/personal-notes/2140dfe09d0306d980b7ea3b615c58bc/autoscale-settings.png\",\n    \"alt\": \"Autoscale settings\"\n  })), mdx(\"p\", null, \"Scaling to a specific instance count only enables you to scale out to a defined number of instances. If you need to scale out incrementally, you can combine metric and schedule-based autoscaling in the same autoscale condition.\"), mdx(\"p\", null, \"You can create multiple autoscale conditions to handle different schedules and metrics. Azure auto-scales your service when any of these conditions apply.\"), mdx(\"p\", null, \"An App Service Plan also has a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"default condition\"), \" that is used if none of the other conditions are applicable. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This condition is always active and doesn't have a schedule\"), \".\"), mdx(\"p\", null, \"An \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"autoscale rule\"), \" specifies a metric to monitor and how autoscaling should respond when this metric crosses a defined threshold. The metrics you can monitor for a web app are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"CPU Percentage\"), \". This metric is an indication of the CPU utilization across all instances. A high value shows that instances are becoming CPU-bound, which could cause delays in processing client requests.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Memory Percentage\"), \". This metric captures the memory occupancy of the application across all instances. A high value indicates that free memory could be running low and could cause one or more instances to fail.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Disk Queue Length\"), \". This metric is a measure of the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"number of outstanding I/O requests\"), \" across all instances. A high value means that disk contention could be occurring.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Http Queue Length\"), \". This metric shows \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"how many client requests are waiting for processing by the web app\"), \". If the length of the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/http-queue\",\n    \"title\": \"http queue\"\n  }, \"[[http queue]]\"), \" is large, client requests might fail with HTTP 408 (Timeout) errors.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Data In\"), \". This metric is the number of bytes received across all instances.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Data Out\"), \". This metric is the number of bytes sent by all instances.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Custom, Azure-based metrics\"), \": You can define thresholds based on metrics on other Azure resources, such as the number of messages stored in an Azure Service Bus queue.\")), mdx(\"p\", null, \"Autoscale works by analyzing trends in metric values over time across all instances. This analysis is a multi-step process:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Aggregate values for the metrics for all instances across a period of time called \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"time grain\"), \". Generally, the time grain is 1 minute. Then it aggregates the values (available \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"time grain statistics\"), \" are \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Average\"), \", \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Minimum\"), \", \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Maximum\"), \", \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Sum\"), \", \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Last\"), \", \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Count\"), \"), and stores the aggreagate value (known as \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"time aggregation\"), \").\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"After a user-defined period (known as \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"duration\"), \"), the process re-runs the calculations. Duration must be longer than time grain. \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"The minimum duration value is 5 minutes\"), \".\")), mdx(\"p\", null, \"An autoscale action has a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"cool down period\"), \", specified in minutes (minimum 5 minutes), during which the scale rules won't be triggered again. This is done to stabilize the system between autoscale events.\"), mdx(\"p\", null, \"Ideally, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"you should pair autoscale rules\"), \": you should create one rule to scale in and one rule to scale out based on the same metric.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A single autoscale condition can contain several autoscale rules\"), \" (for example, a scale-out rule and the corresponding scale-in rule). However, the autoscale rules in an autoscale condition don't have to be directly related.\\nYou could define the following four rules in the same autoscale condition:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the HTTP queue length exceeds 10, scale-out by 1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the CPU utilization exceeds 70%, scale-out by 1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the HTTP queue length is zero, scale-in by 1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the CPU utilization drops below 50%, scale-in by 1\")), mdx(\"p\", null, \"When determining whether to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"scale out\"), \", the autoscale action is performed if \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"any\"), \" of the scale-out rules are met (HTTP queue length exceeds 10 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"or\"), \" CPU utilization exceeds 70%).\\nWhen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"scaling in\"), \", the autoscale action runs only if \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"all\"), \" of the scale-in rules are met (HTTP queue length drops to zero \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"and\"), \" CPU utilization falls below 50%).\"), mdx(\"p\", null, \"If you need to scale in if only one of the scale-in rules is met, you must define the rules in separate autoscale conditions.\"), mdx(\"p\", null, \"All autoscale successes and failures are logged in the Activity Log. You can then \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"configure an activity log\"), \" alert to notify you via email, SMS, or webhooks whenever there's activity.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://learn.microsoft.com/en-us/azure/azure-monitor/autoscale/autoscale-understanding-settings\"\n  }, \"See more\"), \".\"), mdx(\"h2\", null, \"Best practices\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Ensure the maximum and minimum values are different and have an adequate margin between them;\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Choose the appropriate statistic for your diagnostics metric. The most common statistic is \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Average\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Carefully choose the threshold. To avoid \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Flapping\"), \", the scale-out and scale-in criteria should be carefully planned.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Choose a safe default instance count. It's necessary because, when metrics are not available, the service gets scaled to that number.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Configure custom notifications (email, webhook) to get notified when an autoscale activity occurs (or fails).\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Flapping\"), \" is when scale-in and scale-out actions continually go back and forth. It happens because when you add a new instance during a scale-out action, the total percentage of resources is lower than before the scale-out action. If it's lower than the scale-in threshold, the scale-in action takes place, returning to the original situation.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"tableOfContents":{"items":[{"url":"#azure-app-service-autoscale","title":"Azure App Service Autoscale","items":[{"url":"#autoscale-conditions-and-rules","title":"Autoscale conditions and rules"},{"url":"#best-practices","title":"Best practices"}]}]},"outboundReferences":[{"contextLine":"Autoscaling performs [[scale-in-out]] as opposed to scaling up and down.","targetAnchor":null,"refWord":"scale-in-out","target":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"cloud, scaling\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Scale In-Out\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Scaling out\"), \" is the process of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"increasing\"), \" the number of machine instances that are running a web app.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Scaling in\"), \" is the process of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"decreasing\"), \" the number of machine instances that are running a web app.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"9c554517-d42d-544f-81cc-b3814e6ec686","fields":{"slug":"/general/scale-in-out","title":"Scale In-Out"}}}},{"contextLine":"Autoscaling is a feature tightly bound to [[azure-app-service-plan]]. Each Service Plan has an associated scaling limit that cannot be surpassed. Not all service plans support autoscaling. **The development pricing tiers are either limited to a single instance (the F1 and D1 tiers)**, or they only provide **manual scaling (the B1 tier)**. If you've selected one of these tiers, you must first scale up to the S1 or any of the P-level production tiers.","targetAnchor":null,"refWord":"azure-app-service-plan","target":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"type\": \"basic-note\",\n  \"foam_template\": {\n    \"filepath\": \"./azure/azure-app-service-plan.md\"\n  },\n  \"tags\": \"azure, cloud, azure-certifications/az204\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Azure App Service Plan\"), mdx(\"p\", null, \"An \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/azure-app-service\",\n    \"title\": \"azure-app-service\"\n  }, \"[[azure-app-service]]\"), \" always runs in an App Service plan, which defines the set of compute resources available to the app.\"), mdx(\"p\", null, \"One or more apps can be configured to run in the same App Service Plan.\"), mdx(\"p\", null, \"Each App Service plan defines:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Operating System (Windows, Linux)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Region (West US, East US, etc.)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Number of VM instances\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Size of VM instances (Small, Medium, Large)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pricing tier (Free, Shared, Basic, Standard, Premium, PremiumV2, PremiumV3, Isolated, IsolatedV2)\")), mdx(\"p\", null, \"App Service Plans can be reused and configured as independent entities.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/personal-notes/4dd97e0e00d6a280d2408cde832520a2/app-service-plans.png\",\n    \"alt\": \"App Service Plans list\"\n  })), mdx(\"p\", null, \"If you publish some applications under the same App Service Plan, when you need to scale the application the same changes are applied to all the other applications within the same App Service Plan. To scale only a single application, you have to move it to a standalone App Service Plan.\"), mdx(\"p\", null, \"You can \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"potentially\"), \" save money by putting multiple apps into one App Service plan. However, since apps in the same App Service plan all share the same compute resources you need to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"understand the capacity of the existing App Service plan\"), \" and the expected load for the new app.\"), mdx(\"h2\", null, \"Pricing tiers\"), mdx(\"h3\", null, \"Shared compute\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Free\"), \" and \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Shared\"), \" pricing tiers;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the app runs on the same Azure VM as other App Service apps (these apps can belong to other customers)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CPU and computation resources are shared with all the other apps hosted in th same VM;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"resources \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"cannot scale out\"), \";\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"they have a fixed allocated amount of CPU time;\")), mdx(\"h3\", null, \"Dedicated compute\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Basic\"), \", \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Standard\"), \", \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Premium\"), \", \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"PremiumV2\"), \", \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"PremiumV3\"), \" tiers;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"only apps in the same App Service plan share the same compute resources;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"you \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"can scale out\"), \";\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if multiple apps are in the same App Service plan, they all share the same VM instances.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if you have multiple deployment slots for an app, all deployment slots also run on the same VM instances.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if you enable diagnostic logs, perform backups, or run WebJobs, they also use CPU cycles and memory on these VM instances.\")), mdx(\"h3\", null, \"Isolated\"), mdx(\"p\", null, \"Similar to Dedicated compute, but with even more isolation.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Isolated\"), \" and \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"IsolatedV2\"), \" tiers;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"resources are stored in dedicated VMs and Azure Virtual Networks;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"maximum level of isolation;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"maximum scale-out capabilities;\")), mdx(\"h2\", null, \"How to deploy\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CI/CD\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Azure DevOps Services\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"GitHub\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"BitBucket\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Manual\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Git URL as remote repository\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"az webapp up\"), \", which can also create a new App Service\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Zip deployment, using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"curl\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"FTP/FTPS\")))), mdx(\"h2\", null, \"Deployment slots\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Standard\"), \" App Service Plan tier or better.\"), mdx(\"p\", null, \"Used to swap staging and production slots.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"2e1f50f9-b325-599c-a1fe-ba3b67a69725","fields":{"slug":"/azure/azure-app-service-plan","title":"Azure App Service Plan"}}}}],"inboundReferences":[{"contextLine":"[[azure-app-service-autoscale]] monitors the resource metrics of a web app as it runs. It detects situations where other resources are required to handle an increasing workload, and ensures those resources are available before the system becomes overloaded.","referrer":{"parent":{"id":"5cde07c4-ecf8-5820-b43e-7798b7e6f6ea","fields":{"slug":"/azure/azure-app-service","title":"Azure App Service"}}}},{"contextLine":"  - [[azure-app-service-autoscale]]","referrer":{"parent":{"id":"054932f3-ea86-5292-9b43-2c04a7a196ec","fields":{"slug":"/azure-certifications/az-204","title":"AZ-204 - Developing Solutions for Microsoft Azure"}}}}]},"fields":{"slug":"/azure/azure-app-service-autoscale","title":"Azure App Service Autoscale"}}},"pageContext":{"id":"bcfce2d9-1479-5b46-a302-c65a9f87670f","refWordMdxSlugDict":{"scale-in-out":"general/scale-in-out","azure-app-service-plan":"azure/azure-app-service-plan","azure-app-service":"azure/azure-app-service","scale-up-down":"general/scale-up-down","azure-app-services-deployment-slots":"azure/azure-app-services-deployment-slots","azure-app-services-multitenant-networking":"azure/azure-app-services-multitenant-networking","azure-virtual-network":"azure/azure-virtual-network","azure-expressroute":"azure/azure-expressroute","azure-network-scripts":"azure-cli/azure-network-scripts","azure-app-service-scripts":"azure-cli/azure-app-service-scripts","azure-app-service-autoscale":"azure/azure-app-service-autoscale"},"tocTypes":["sidebar"]}},
    "staticQueryHashes": ["2221750479","2380733210","2768355698","63159454","847517413"]}